import urllib
import pandas as pd
import shapefile
import numpy as np
import pandas as pd
import pickle
import os
import sys
from os.path import exists, join
from shapely.geometry import Polygon, MultiPolygon, Point
import matplotlib.path as mplPath
from tqdm import tqdm
import matplotlib.pyplot as plt
import geopandas
import geojson


"""
This script estimate the total length of power lines across the entire utility territory
that would be potentially affected by fire-prone power lines in each block group.
It will be further used to estimate the number of buildings that could be potentially affected.
The algorithm is based on the Breadth First Search algorithm run on distribution grids.
"""

# This wildfire probability (%) defines fire-prone overhead lines.
# Note that we only estimate the line-burying status for power lines where fire prob > 0.25%,
# so any threshold value < 0.25% is equivalent to fireprob_thres = 0.25.
fireprob_thres = 0.0 # in terms of %

save_path = join('results/intermediate/outage_simulation_new', 'results_by_bg_' + str(fireprob_thres) + '_with_edges.pickle')

with open('results/intermediate/PGE_substation_connection_dict.pickle', 'rb') as f:
    substation_connection_dict = pickle.load(f) # mapping feeder to the nearest substation
with open('results/intermediate/unconnected_feederID_list.pickle', 'rb') as f:
    unconnected_fid_list = pickle.load(f) # feeders that are not mapped to any substation
with open('results/intermediate/feederID2feeder_cluster.pickle', 'rb') as f:
    fid2cluster = pickle.load(f) # mapping feeder its corresponding cluster/interconnection
with open('results/intermediate/PGE_edge_set_by_feeder.pickle', 'rb') as f:
    edge_set_by_feeder = pickle.load(f) # power lines (i.e., edges) in each feeder
with open('results/intermediate/bg2edgeinfo_including_auxiliary.pickle', 'rb') as f:
    bg2edges = pickle.load(f) # power line (i.e., edge) information in each block group

# add auxiliary edges (to formulate a fully connected graph for each feeder)
edge_to_add_list_dict = {}
for jj in [0, 1, 2]:
    with open('results/intermediate/auxiliary_edges_dict/auxiliary_edges_dict_' + str(jj) + '.pickle', 'rb') as f:
        edge_to_add_list_dict_sub = pickle.load(f)
    for fid in edge_to_add_list_dict_sub:
        edge_to_add_list_dict[fid] = edge_to_add_list_dict_sub[fid]
        
print('Data loaded')
        
edge2bg_length = {} # edge (pid1, pid2) to a list of [bfips, line length]
bg2total_length = {} # the total line length for a block group
for bfips in bg2edges:
    total_length = 0
    for fid, edge, underground, fireprob_val, length in bg2edges[bfips]:
        total_length += length
        if not edge in edge2bg_length:
            edge2bg_length[edge] = []
        edge2bg_length[edge].append((bfips, length))
    bg2total_length[bfips] = total_length


def BFS(g, s_list):
    """Breadth First Search Algorithm."""
    L = {}
    visited = set(s_list)
    L[0] = set(s_list)
    i = 0
    while True:
        for node in L[i]:
            for nb in g[node]:
                if not nb in visited:
                    visited.add(nb)
                    if i+1 not in L:
                        L[i+1] = set()
                    L[i+1].add(nb)
        if i+1 not in L:
            break
        i += 1
    return L, visited

def construct_undirected_graph_dict(edge_set):
    """
    Construct a graph data structure (as a dict) for
    the distribution grid.
    """
    graph_dict = {}
    for node1, node2 in edge_set:
        if node1 not in graph_dict:
            graph_dict[node1] = set()
        graph_dict[node1].add(node2)
        if node2 not in graph_dict:
            graph_dict[node2] = set()
        graph_dict[node2].add(node1)
    return graph_dict


def get_unconnected_edges(fid_set, failed_edges = set()):
    all_involved_fid_set = set()
    involve_isolated_feeder = False # Whether this run involves feeders without connection with substations
    for fid in fid_set:
        if fid in unconnected_fid_list and len(fid2cluster[fid]) == 1: 
            # this feeder has no attached substation nor interconnection with any other feeders
            involve_isolated_feeder = True
            print('Warning: feeder ' + str(fid) + \
            ' is ignored because this feeder has no attached substation\nnor interconnection with any other feeders')
            continue
        all_involved_fid_set = all_involved_fid_set.union(fid2cluster[fid])
    all_edge_set = []
    source_stations = set() # the starting points (i.e. substations) to run BFS
    for fid in all_involved_fid_set:
        if fid in unconnected_fid_list and len(fid2cluster[fid]) == 1:
            continue
        all_edge_set += list(edge_set_by_feeder[fid])
        all_edge_set += edge_to_add_list_dict[fid] # auxiliary edges 
        if fid in substation_connection_dict:
            station_edge = substation_connection_dict[fid]
            all_edge_set.append(station_edge)
            source_stations.add(station_edge[0])
    all_edge_set = set(all_edge_set)
    remaining_edge_set = all_edge_set - failed_edges # remove failed edges from the all_edge_set
    graph_dict = construct_undirected_graph_dict(remaining_edge_set)
    _, visited_nodes = BFS(graph_dict, list(source_stations))
    unvisited_edges = set()
    for edge in remaining_edge_set:
        if edge[0] not in visited_nodes and edge[1] not in visited_nodes:
            unvisited_edges.add(edge)
    return unvisited_edges, involve_isolated_feeder


def get_failed_edges(bfips, fireprob_threshold):
    """
    Obtain the overhead edges (i.e., overhead power lines) in the given 
    block group that could be affected by wildfires.
    """
    failed_edges = set()
    fid_set = set()
    failing_length = 0
    for fid, edge, underground, fireprob_val, length in bg2edges[bfips]:
        if np.isnan(fireprob_val) == False and fireprob_val >= fireprob_threshold and underground == 0:
            failed_edges.add(edge)
            fid_set.add(fid)
            failing_length += length
    return failed_edges, fid_set, failing_length


def get_outage_length(bfips, failing=True, fireprob_threshold=0.25, return_edges=False):
    """
    Obtain all edges (i.e., power lines, not limited to the given 
    block group but across the entire utility territory) in the given 
    block group that could be affected by wildfires.
    """
    failed_edges, fid_set, failing_length = get_failed_edges(bfips, fireprob_threshold)
    if failing == False:
        failed_edges = set()
    unvisited_edges, involve_isolated_feeder = get_unconnected_edges(fid_set, failed_edges = failed_edges)
    outage_lengths_by_bg = {}
    failed_edge_length = 0
    for edge in unvisited_edges:
        for bg, length in edge2bg_length[edge]:
            if not bg in outage_lengths_by_bg:
                outage_lengths_by_bg[bg] = 0
            outage_lengths_by_bg[bg] += length
    for edge in failed_edges:
        for bg, length in edge2bg_length[edge]:
            if not bg in outage_lengths_by_bg:
                outage_lengths_by_bg[bg] = 0
            outage_lengths_by_bg[bg] += length
            failed_edge_length += length
    if not outage_lengths_by_bg:
        return failed_edge_length, None, involve_isolated_feeder
    outage_lengths_by_bg = pd.DataFrame(outage_lengths_by_bg.items())
    outage_lengths_by_bg.columns = ['blockgroup_FIPS', 'outage_lengh'] 
    if return_edges:
        return failed_edge_length, outage_lengths_by_bg, involve_isolated_feeder, unvisited_edges, failed_edges
    else:
        return failed_edge_length, outage_lengths_by_bg, involve_isolated_feeder

samples = []
for bfips in bg2edges:
    failed_edges, fid_set, failing_length = get_failed_edges(bfips, fireprob_thres)
    if fid_set:
        samples.append((bfips, fid_set))

# run
if exists(save_path):
    with open(save_path, 'rb') as f:
        result_dict = pickle.load(f)
else:
    result_dict = {}

cnt = 0
for bfips, fid_set in tqdm(samples):
    if bfips in result_dict:
        continue
    cnt += 1
    failed_edge_length, outage_lengths_by_bg, involve_isolated_feeder, unvisited_edges, failed_edges = get_outage_length(bfips, True, fireprob_thres, return_edges=True)
    if outage_lengths_by_bg is not None:
        total_length_list = []
        for idx in outage_lengths_by_bg.index:
            bg = outage_lengths_by_bg.loc[idx, 'blockgroup_FIPS']
            total_length_list.append(bg2total_length[bg])
        outage_lengths_by_bg['total_length'] = total_length_list
        outage_lengths_by_bg['outage_ratio'] = outage_lengths_by_bg['outage_lengh'] / outage_lengths_by_bg['total_length']
    result_dict[bfips] = {'df': outage_lengths_by_bg, 'failed_line_length': failed_edge_length, 
                          'involve_isolated_feeder': involve_isolated_feeder, 'failed_edges': failed_edges, 'unconnected_edges': unvisited_edges}
    if cnt % 100 == 0:
        with open(save_path, 'wb') as f:
            pickle.dump(result_dict, f)
            
with open(save_path, 'wb') as f:
    pickle.dump(result_dict, f)

print('Done.')

    